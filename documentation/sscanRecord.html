<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>The SSCAN record v5.18</title>
</head>
<body>
<h1>
The SSCAN record v5.18</h1>
Author: Tim M. Mooney<br>
Based on the scan record, written by Ned D. Arnold.<br>
<p>&nbsp;Advanced Photon Source
<br>&nbsp;Argonne National Laboratory

<P>Contents:

<br><a href="#HEADING_1"><b>1.&nbsp;&nbsp;&nbsp;</b> Introduction</a>

<br><a href="#HEADING_1-1"><b>1.1.</b> A Simple One 
Dimensional Scan</a>

<br><a href="#HEADING_1-2"><b>1.2.</b> Multidimensional
Scans</a>

<br><a href="#HEADING_1-3"><b>1.3.</b> Handshaking with clients</a>

<br><a href="#HEADING_1-4"><b>1.4.</b> Completion of positioner and
detector-trigger operations</a>

<br><a href="#HEADING_2"><b>2.&nbsp;&nbsp;&nbsp;</b> Scan Parameters</a>

<br><a href="#HEADING_2-0"><b>2.0.</b> Global Parameters</a>

<br><a href="#HEADING_2-1"><b>2.1.</b> Positioner Parameters</a>

<br><a href="#HEADING_2-2"><b>2.2.</b> Linear Mode</a>

<br><a href="#HEADING_2-3"><b>2.3.</b> Table Mode</a>

<br><a href="#HEADING_2-4"><b>2.4.</b> Position Verification,
Readback Process Variable, and Delta Parameters</a>

<br><a href="#HEADING_2-5"><b>2.5.</b> Detector Trigger
s and Command Data</a>

<br><a href="#HEADING_2-6"><b>2.6.</b> Delay variables</a>

<br><a href="#HEADING_2-7"><b>2.7.</b> Client handshaking variables</a>

<br><a href="#HEADING_3"><b>3.&nbsp;&nbsp;&nbsp;</b> Data Acquisition
Parameters</a>

<br><a href="#HEADING_4"><b>4.&nbsp;&nbsp;&nbsp;</b> Operator Display
Parameters</a>

<br><a href="#HEADING_5"><b>5.&nbsp;&nbsp;&nbsp;</b> Run-time Parameters</a>


<p><a NAME="HEADING_1"></a>
<h1>1. Introduction</h1>

<hr>The purpose of the SSCAN record is to move <i>positioners</i> through a
series of positions and record <i>detector</i> data at each of the positions.
The whole sequence of operations is referred to as a <i>scan</i>, or as one
loop of a multi-dimensional scan.  After parameters defining the scan have been
initialized and the scan has been launched, the SSCAN record begins a possibly
long and involved sequence of operations normally without further input, and 
notifies any interested clients as the scan progresses. The data are collected
into arrays within the record so that they needn't be written point by point by
a client.

<p>A single SSCAN record supports a one dimensional scan. Several SSCAN records
can be linked together to perform a multi-dimensional scan.  Each SSCAN record
can control up to four positioners, trigger up to four detectors, and acquire
data from up to 74 process variables (70 detector values of type <tt>float</tt>
and four positioner readbacks of type <tt>double</tt>).

<p>&nbsp;Typically, the SSCAN record moves motors and acquires scaler data at
each motor position, but obviously it can also be used for other purposes. Any
writable EPICS PV (process variable) can be scanned through a set of values
while data are recorded from any other PVs.  For example, one of the positioner
PVs could be used to vary the gain or dwell time  of a detector during a scan. 
Therefore, throughout this document the term <i>positioner</i> should be taken
to mean "any PV to which you can write a number".Similarly, the term
<i>detector trigger</i> typically refers to a PV that will cause data
acquisition to begin when it is written to, but could be taken to mean any PV
to which you can write a number. Finally, the term <i>detector</i> refers to
any readable numeric PV.

<P>The SSCAN record normally acquires sets of scalar data values and assembles
them into arrays, but it can also acquire arrays directly from array-valued
PVs.  The end results can only be one-dimensional arrays, however; a single
SSCAN record cannot acquire multi-dimensional data.

<p>&nbsp;All of the process variable names used to identify positioners,
detectors, and detector triggers are specified using <i>reassignable links</i>.
This allows a scan to be configured on the fly.  Currently, these links are
implemented with the recDynLink library, which is distributed along with the
<b>scan</b> module.  In the future, they will be converted to use
dbCaPutCallback, which is part of EPICS base.

<p><a NAME="HEADING_1-1"></a>

<h2>1.1. A Simple One Dimensional Scan</h2>

In the simplest reasonably complete configuration for a one-dimensional scan,
the following fields are used:

<DL>
<DT><tt>P1PV</tt> <DD>the name of a positioner (e.g., "myMotor.VAL")
<DT><tt>P1SP</tt> <DD>start position -- the first position at which data will be acquired
<DT><tt>P1EP</tt> <DD>end position -- the last position at which data will be acquired
<DT><tt>NPTS</tt> <DD>the total number of positions to visit
<DT><tt>T1PV</tt> <DD>the name of a detector-trigger PV.  This PV will be written to after the positioner has arrived at each position.
<DT><tt>D01PV</tt> <DD>the name of a detector (signal) PV.  The value of this PV will be recorded after the detector-trigger has finished acquiring data.
</DL>

When a scan is started (by writing a "1" to the <tt>EXSC</tt> field) the SSCAN
record commands the positioner to move to its starting position.  The SSCAN
record uses recDynLinkPutCallback() to tell the positioner to move, and waits
for the resulting callback, indicating that the positioner is finished, before
moving on to the next step of the scan, which is to trigger the detector.&nbsp;
The detector is also triggered using  recDynLinkPutCallback(), and the SSCAN
record waits for it to finish before going on to the next data point. This
algorithm continues until the SSCAN record has completed <tt>NPTS</tt> steps,
or the scan is aborted. At the end of the scan, the SSCAN record has filled in
an array of the positions visited (<tt>P1RA</tt>), and an array of detector
values acquired (<tt>D01DA</tt>).

<P>Let's run through that again, this time more generally, with more detail, and
including more of the available options.
<DL>

<DT>Positioners

<DD>You can specify zero to four positioners.  Positioners are expected to tell
the SSCAN record when they're done moving (more about this later).  After all
positioners have declared themselves done, the SSCAN record waits for a
user-specified settling time (<tt>PDLY</tt>, normally zero) before firing
detector triggers.  (If no positioners, then no positioner settling time.)

<DT>Positions to visit <DD>There are lots of possibilities here.  You can
specify any combination of the set [start, end, center, width, step-size] for
each positioner; you can load a table of positions for each positioner; or you
can specify that positioners are to be moved continuously during a scan.  You
can specify that positions be regarded as absolute, or as relative to the
pre-scan position.

<DT>Detector triggers

<DD>Detector triggers act much like positioners, in that they write a value and
wait for any ensuing processing to finish, but they send the same value at
every data point (<tt>TnCD</tt>).  After all detectors have declared themselves
done, the SSCAN record waits for a user-specified settling time (<tt>DDLY</tt>,
normally zero) before reading data from detector-signal PVs.  (If no detector
triggers, then no detector settling time.)


<DT>Detector signals

<DD>Normally, detector signals are scalar PV's, but they can be array-valued
PV's.  If so, the SSCAN record will read them at the end of the scan.  If
array-valued PVs require processing to acquire their values, the SSCAN record
can fire a special array trigger (<tt>A1PV</tt> <tt>A1CD</tt>, exactly
analogous to detector triggers), and wait for any ensuing processing to finish
before reading the arrays.  If all detector signals are array valued, it's
probably better to use array mode (see <tt>ACQT</tt>).

<P>Detector-signal values can be accumulated from scan
to scan, so you can sweep over a set of positions, building up statistical precision and averaging over any positioning errors or variable external conditions.

<DT>After the scan
<DD>You can tell positioners what to do after the scan is finished, using the
<tt>PASM</tt> field.  The default behavior is simply to remain where the scan
left them, but you could tell them to return to their pre-scan positions, go
to their start positions, or go to positions calculated from acquired data
(e.g., the position at which a specified detector signal <tt>REFD</tt> reached
its peak value during the scan).
</DL>


<p><a NAME="HEADING_1-2"></a>
<h2>1.2. Multidimensional Scans</h2>

Multidimensional scans are easy: an outer-loop SSCAN record (which we'll call
"scan2") regards an inner-loop SSCAN record ("scan1") as a detector to be
triggered, and each SSCAN record acquires its own data.  Thus,
<tt>scan2.T1PV</tt>, is set to <tt>scan1.EXSC</tt>, and <tt>scan2.T1CD</tt> is
set to 1.  In words, scan2 writes a "1" to the "execute scan" field
(<tt>EXSC</tt>) of scan1.

<p>&nbsp;To initiate the scan, the scan2 record is commanded to begin 
(<tt>scan2.EXSC</tt> is set to "1").  scan2 sends its <i>positioners</i> to
their starting points, and waits for their callbacks.  Then scan2 writes to its
<i>Detector Trigger</i>(s), (one of) which in this case causes scan1 to begin its own scan.
The scan1 record will now go through its entire programmed scan, acquiring data
from its detectors at each point.

<p>&nbsp;When scan1 is finished, and its data have been written (or at least
secured), its callback causes scan2 to continue in its scan procedure -- reading
detector values, moving positioners to new positions, and causing scan1 to
execute again.

<p>This approach to configuring multidimensional scans is very flexible and
permits scans of any dimension.  Note that scan1 can be executed independently
of scan2, so a complex multidimensional scan can be built and tested one
dimension at a time.  (In principle, it's possible to run several inner-loop
scans in parallel from an outer-loop scan, but in practice, the capability is
of limited use, because there is no coordination between the scans, and no
data-storage client exists that would correctly understand the acquired data.)

<P>An outer SSCAN record involved in a multidimensional scan doesn't know or care
that the "detector" it's triggering is actually another SSCAN record, which is
going to do an entire inner scan; the outer SSCAN record simply triggers what
it regards as a detector, and waits for that detector to complete.  Nor do the
inner SSCAN records know that they are parts of something larger than
themselves.  The only piece of code that has to know a multidimensional scan is
occurring is the client that stores the data.  This client must collect all of
the data from each inner scan before those data are overwritten by the next
execution of that inner scan, because SSCAN records hold only one-dimensional
arrays of data.

<P>Clearly, this calls for some handshaking between the client and the
SSCAN records involved in a multidimensional scan.  The next section
describes the handshake mechanisms implemented by the SSCAN record.

<p><a NAME="HEADING_1-3"></a>
<h2>1.3. Handshaking with clients</h2>
<h3>1.3.1 Handshaking with data-storage clients</h3>
<P>1) <B>The new way, using the <tt>AWAIT</tt> and <tt>AAWAIT</tt> fields:</B>
<P>The data-storage client waits for <tt>DATA==1</tt>, which indicates that the
SSCAN record has finished posting all array fields; writes "1" to the
<tt>AWAIT</tt> field to prevent the SSCAN record from overwriting array
fields before the client has read them; and writes "0" to <tt>AWAIT</tt> when
it is finished reading.  One advantage of this handshake is that it allows the
SSCAN record to proceed with the next scan (the SSCAN record's data arrays are
double buffered) until it's time to post data.  In this way, the data-storage
client can be writing one set of scan data while the SSCAN record is acquiring
the next set.

<P>For <em>very</em> fast scans, or very slow data-storage clients, there might
not be sufficient time, between the posting of one data set and the acquisition
of the next, for the client to write "1" to <tt>AWAIT</tt> (array wait) field. 
In this case, you can cause the SSCAN record automatically to set
<tt>AWAIT==1</tt>, whenever it posts data, by setting the <tt>AAWAIT</tt> (auto
array wait) field to "1".  (It's OK if the client also sets <tt>AWAIT==1</tt>.)

<P>Note that this <tt>AWAIT</tt> handshake protects scan data no matter how the
SSCAN record gets executed, unlike the old method described next.

<P>2) <B>The old way, using the <tt>WAIT</tt>, <tt>WCNT</tt>, and <tt>AWCT</tt>
fields:</B>

<P>Before the <tt>AWAIT</tt> field was introduced, the only means of
handshaking was an extension of the mechanism by which the SSCAN record waits
for detector triggers to signal completion.  In this extension, the SSCAN
record waits until all detector triggers have signalled completion,
<em>and</em> the field <tt>WAIT</tt> is equal to zero.  This extension's
intended purpose is to support detectors that can't signal completion with a
callback, but that can write to a PV -- for example, a detector that's
implemented as a channel-access client -- and it can still be used for that
purpose, while a data-storage client is using it to protect data acquired from
an inner-loop scan. 

<p>Here's how the handshake works in a data-storage application:  The data-storage client notices that an inner SSCAN record has started a scan (typically,
it monitors the <tt>DATA</tt> field, which is set to zero at the beginning of a scan), and writes a "1" to the outer SSCAN record's <tt>WAIT</tt> field.  This
prevents the outer SSCAN record from continuing until the client has
read the inner scan's data.  The client waits for <tt>DATA==1</tt>, which indicates that new data are available.  When the client has finished reading
the inner scan's data, it writes a "0" to the outer SSCAN record's <tt>WAIT</tt>
field, allowing the scan to continue.

<P>If there are several clients that want the scan to <tt>WAIT</tt> for them,
they can all write to the <tt>WAIT</tt> field.  Each "1" increments the scan's
wait-count field, <tt>WCNT</tt>; each "0" decrements it.  When <tt>WCNT</tt> reaches zero, the scan continues.

<p>In fast scans, there might not be time for a client to notice that an
inner scan has started and write that "1" to the outer scan's <tt>WAIT</tt>
field before the inner scan completes and is triggered again.  In this case,
the outer scan can be made automatically to write a "1" to it's own
<tt>WAIT</tt> field whenever it triggers detectors.  It will do this if its AutoWaitCounT (<tt>AWCT</tt>) field is set to "1".  In this case,
the client must NOT write another "1" to the outer scan's <tt>WAIT</tt> field
(that would increment the wait count to 2), but must only write "0" to the
<tt>WAIT</tt> field to indicate that it is ready for the scan to continue.

If there are N clients, the autoWaitCount can be set to N, and the scan
will continue only after N "0"s have been written to the <tt>WAIT</tt> field.

The advantage of the autoWaitCount==0 method is that scans can be performed whether or not a client is available to write to the <tt>WAIT</tt> field.  The
disadvantage is that the is not reliable for vry fast scans.

Note that this form of handshaking doesn't do a very thorough job of data
protection, because it does not directly prevent a SSCAN record from
overwriting its own arrays; it only prevents an outer-loop SSCAN record from
<em>telling</em> an inner-loop record to overwrite its arrays.  If the SSCAN
record is executed by some other agent, the <tt>WAIT</tt> handshake doesn't protect data
at all.

<h3>1.3.2 Handshaking with CA clients that implement positioners or detectors</h3>

A channel-access client can participate in scans driven by the SSCAN record if
two criteria are met:

<OL>

<LI>The client is driven by a PV to which one of the SSCAN record's
detector-trigger links writes.

<LI>The client can signal completion in a way that the SSCAN record understands.

</OL> 

<P>There are two mechanisms the client can use to signal completion that will
work with the SSCAN record:

<DL>

<DT>putNotify-based completion signalling

<DD> This is the method the SSCAN record uses to drive other records.  Clients
can't do this directly, but they can do it indirectly, using a BUSY record.  A
BUSY record is a custom EPICS record, supplied as part of the synApps package,
that looks and operates almost exactly like the binary-output record, except
that it fires its forward link, <tt>FLNK</tt>, only when its <tt>VAL</tt> field
has the value zero.  As it happens, EPICS putNotify completion mechanism is
implemented as part of the processing of forward links, so the fact that the
busy record allows a CA client to control the firing of a forward link means
that the client can control the timing of a putNotify callback.

<P>Here's how it works in practice: some developer causes a BUSY record (let's
call it <tt>detBusy</tt>) to be loaded into the IOC; the SSCAN record writes
"1" to a <tt>detBusy.VAL</tt>; the client monitors <tt>detBusy.VAL</tt>, and
begins some operation when it goes to "1"; when processing is complete, the
client writes "0" to <tt>detBusy.VAL</tt>; this causes the record to fire its
forward link, EPICS sends a callback to the SSCAN record, and the scan
proceeds.

<P>Very simple, but it does require a dedicated record to be added to some IOC.
Many of the databases in synApps contain BUSY records for this purpose,
particularly those that act as front ends for State-Notation_Language (SNL)
code.  Though motivated by the needs of the SSCAN record, this
completion-signalling capability can be used by any CA client.

<P><DT><tt>WAIT</tt>-field handshake with the SSCAN record. <DD>This handshake
is intended for CA clients implementing detectors, though as detailed above, it
can also be useful for data-storage clients. In the detector case, the client
monitors some PV (that needn't be the <tt>VAL</tt> field of a BUSY record). 
The SSCAN record writes some value to this PV, which the client regards as a
start command; the client writes "1" to <tt>scanrecord.WAIT</tt>, indicating
that it wants the SSCAN record to wait; the client performs its
data-acquisition task; the client writes "0" to <tt>scanrecord.WAIT</tt>,
indicating that it's done. Several clients can use the <tt>WAIT</tt> field,
each write of "1" increments a wait count <tt>WCNT</tt>; each "0" decrements
<tt>WCNT</tt>; the SCAN record stops waiting when <tt>WCNT</tt> is decremented
to zero.

<p>The only problem is the possibility that the SSCAN record might check
its wait-count <tt>WCNT</tt> before the client has had time to write "1" to it.
In this case, you can cause the SSCAN record to write the "1" itself, by
setting <tt>scanrecord.AWCT</tt> to "1".  But now the client must NOT also
write "1", because that would increment <tt>WCNT</tt> to "2".
</DL> 

<p><a NAME="HEADING_1-4"></a>
<h2> 1.4. Completion of positioner and
detector-trigger operations</h2>

<p>&nbsp;As was mentioned previously, all of
the process variable names used to identify positioners, detectors, and
detector triggers are specified using <i>reassignable links</i>.  These links
are implemented differently than standard EPICS links.  Reassignable links are
channel-access links implemented with the recDynLink library (originally
written by Marty Kraimer and Ned Arnold, modified to use callbacks and
currently maintained by Tim Mooney, to be replaced eventually by
dbCaPutCallback).  These links perform writes with the channel-access function,
<tt>ca_put_callback()</tt>, and expect the callback function to be called only
after all processing caused by the write operation is complete. For simple
positioners and detectors, this is never a problem.  Inidividual records using
either <i>synchronous</i> or <i>asynchronous</i> completion strategies (as
these terms are defined in the EPICS Application Developer's Guide) always
satisfy the completion-callback criterion.  Special records (MOTOR, SCALER,
MCA, and SSCAN record) which do not use either synchronous or asynchronous
strategies have been engineered to satisfy the completion-callback criterion
simply by having them refrain from calling recGblFwdLink() (i.e., from firing
their Forward Links) until the operation they started has finished.

<p>If a positioner or detector is implemented with a collection of linked
records all of which individually satisfy the completion-callback criterion,
the whole series of records will also satisfy the criterion <b>if</b> all links
in the processing chain started by the sscan record's write have the attribute
PP, and all of the records that process are scan-passive (i.e., their .SCAN
fields are set to "Passive").  Databases that do not satisfy this criterion can
still satisfy the completion-callback criterion very simply: at least one
record in the database must refrain from firing its Forward Link until the
operation is finished, and that record must be either be the record written to,
or it must be linked with attribute PP to the record.  The BUSY record was
implemented for this purpose.  Using the BUSY record, any sort of processing,
even processing that involves an external, non-EPICS processor can esily
satisfy the completion-callback criterion.

<p>Database developers should note that a PP link from a record in one crate to a record in another crate will silently be converted to a CA link, which will not satisfy the completion-callback criterion.  In this case, there are two options: the BUSY-record solution, and using
either the SSCAN record or the SWAIT record to make the inter-crate link.  (The SWAIT record is
a variant of the EPICS WAIT record that uses <tt>ca_put_callback()</tt> to implement its output link, just as the SSCAN record does.)  Because only these two record types request and wait for completion callbacks from records they write to, only they can send scan commands to another crate.

<p><a NAME="HEADING_2"></a>

<h1>2. Scan Parameters</h1>

<hr>Many options are available to control the execution of a scan. All
parameters for a particular SSCAN record must be configured prior to initiating
the scan, as the SSCAN record will not allow most fields to be written to while
a scan is in progress.  However, in a multidimensional scan, outer scans can
modify the parameters of inner scans, because at the time an outer SSCAN record
is writing to positioners, all inner SSCAN records are idle. You should use
caution in programming such self modifying scans, because clients displaying
and storing multidimensional-scan data may have trouble dealing with parameters
changing during a scan.

<P>In this documentation, many of the SSCAN-record PV's will be listed in
tables containing the following informational headings:

<dl>

<dt><b>Field</b></dt>

<dd>The name of the SSCAN-record field</dd>

<dt><b>Summary</b></dt>

<dd>Basic purpose of the field</dd>

<dt><b>Type</b></dt>

<dd>Data type of the field.  If the field is a menu, the menu choices (text
strings) are listed in quotes.  (Don't include the quotes when you write to the
field.)  Note that if you write a numeric value to a menu field, the number
will be interpreted as an index into the list of menu choices.  The first item
in the list has the index 0.</dd>

<dt><b>DCT</b></dt>

<dd>Can this field be modified by database-configuration tools?</dd>

<dt><b>Initial/Default</b></dt>

<dd>Value if the field is not specified in the .db file.  If the field is a
menu, the text string will be shown, followed by the corresponding index. </dd>

<dt><b>Read</b></dt>

<dd>Can user read this field?</dd>

<dt><b>Modify</b></dt>

<dd>Is user ever allowed to write to this field?  (Note that the SSCAN record
will reject writes to certain otherwise writable fields while a scan is
underway.)</dd>

<dt><b>Posted</b></dt>

<dd>If the record should modify the field, will the new value be posted?</dd>

<dt><b>PP</b></dt>

<dd>Does a channel-access write to this field cause the record to process?</dd>

</dl>

<p><a NAME="HEADING_2-0"></a>

<h2>2.0. Global Parameters</h2>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>NPTS</tt></td>
<td>Number of Points&nbsp;</td>
<td>SHORT</td>
<td>Yes</td>
<td>100</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>MPTS</tt></td>
<td>Maximum Number of Points</td>
<td>SHORT</td>
<td>Yes</td>
<td>100</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr colspan=9><td colspan=9></td></tr>

<tr>
<td><tt>PASM</tt></td>
<td>Positioner After-Scan Mode</td>
<td>Menu ("STAY", "START POS", "PRIOR POS", "PEAK POS", "VALLEY POS", "+EDGE POS",  "-EDGE POS")</td>
<td>Yes</td>
<td>"STAY" (0)</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>

<td colspan=9>PASM allows the user to control where positioners are left after
a scan is finished.  Here are the possibilities:

<dl compact>

<dt>"STAY"<dd>Do nothing.  Leave positioners where they were when the last data
point was acquired.

<dt>"START POS"<dd>Go the the position of the first data point acquired.

<dt>"PRIOR POS"<dd>Go to the position they occupied prior to the scan.

<dt>"PEAK POS"<dd>Attempt to find the highest point in the data from the
detector specified by the REFD field.  If a highest point is found, go to its
position, else "STAY".

<dt>"VALLEY POS"<dd>Attempt to find the lowest point in the data from the
detector specified by the REFD field.  If a lowest point is found, go to its
position, else "STAY".

<dt>"+EDGE POS"<dd>Take the derivative of the REFD data, then do "PEAK POS".

<dt>"-EDGE POS"<dd>Take the derivative of the REFD data, then do "VALLEY POS".

</dl> 
</td>
</tr>

<tr>
<td><tt>REFD</tt></td>
<td>Reference detector for After-Scan mode</td>
<td>SHORT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr colspan=9><td colspan=9></td></tr>

<tr>
<td><tt>BSPV</tt></td>
<td>Before-Scan Process Variable link</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>BSNV</tt></td>
<td>BSPV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>BSCD</tt></td>
<td>Before-Scan Command Data</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>BSWAIT</tt></td>
<td>Wait for completion?</td>
<td>MENU ("YES", "NO")</td>
<td>Yes</td>
<td>"YES" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr colspan=9><td colspan=9></td></tr>

<tr>
<td><tt>ASPV</tt></td>
<td>After-Scan Process Variable link</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>ASNV</tt></td>
<td>ASPV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>ASCD</tt></td>
<td>After-Scan Command Data</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>ASWAIT</tt></td>
<td>Wait for completion?</td>
<td>MENU ("YES", "NO")</td>
<td>Yes</td>
<td>"YES" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr colspan=9><td colspan=9></td></tr>

<tr>
<td><tt>A1PV</tt></td>
<td>Array-read trigger 1 PV Name</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>A1NV</tt></td>
<td>A1PV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>A1CD</tt></td>
<td>A1 Cmnd</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>

<p><a NAME="HEADING_2-1"></a>

<h2>2.1. Positioner Parameters</h2>

Each SSCAN record may control up to four <i>positioners</i> that are commanded
to a new <i>desired position</i> after collecting data at each point. The
positioners are defined by typing in an ASCII string that represents the
process variable name of the positioner.

<p>There are three modes for determining the desired value for the positioner.
The desired mode is specified in the <tt>P1SM</tt>-<tt>P4SM</tt>  fields:
<tt>Linear</tt>, <tt>Table</tt>, and <tt>On-The-Fly</tt>. If a positioner is
specified as <tt>Linear</tt>, its desired value is determined by using
parameters such as start position, step increment, number of points, and end
position (which are explained below). If a positioner is specified as
<tt>Table</tt>, its next position is found in an array that has been loaded
into the record prior to initiating a scan. If the positioner is specified as
<tt>On-The-Fly</tt>, the SSCAN record sends it to the start position at the
beginning of a scan, waits for it to get there, acquires one data point,  sends
the positioner to the end position, and begins acquiring the remaining data
points while the positioner presumably is travelling to the end position.

<P>Currently, the SSCAN record does not wait for an <tt>On-The-Fly</tt>
positioner to arrive at the end point.  Ideally, the SSCAN record should finish
the data-acquisition portion of a scan but not enter the post-scan phase
(sending positioners to after-scan positions, and executing the after-scan
link) until the positioner has declared itself done.  But currently this is not
what is done.

<P>For <i>n</i> in [1..4]:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>P<i>n</i>PV</tt></td>
<td>Positioner <i>n</i> Process Variable ame</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>NV</tt></td>
<td>P<i>n</i>PV Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>SM</tt></td>
<td>Positioner <i>n</i> Step Mode</td>
<td>Menu ("LINEAR", "TABLE", "FLY")</td>
<td>Yes</td>
<td>"LINEAR" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>AR</tt></td>
<td>Positioner <i>n</i> Absolute/Relative Mode</td>
<td>Menu ("ABSOLUTE", "RELATIVE")</td>
<td>Yes</td>
<td>"ABSOLUTE" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>

<p><a NAME="HEADING_2-2"></a>

<h2> 2.2. Linear Mode</h2>

If a positioner's step mode field (<tt>P1SM</tt>) specifies <tt>Linear</tt>, a
scan can be fully defined by three parameters, e.g., the start position
(<tt>P1SP</tt>), the step increment (<tt>P1SI</tt> ), and the number of data
points (<tt>NPTS</tt>). A scan involving <i>N</i> positioners is defined by
merely 2<i>N</i>+1 parameters, since <tt>NPTS</tt> applies to all positioners.
For the convenience of interactive users, and to support channel access clients
that define scans differently, the first positioner can be specified by as many
as six parameters: starting position (<tt>P1SP</tt>), ending position
(<tt>P1EP</tt>), center position (<tt>P1CP</tt> ), scan  width (<tt>P1WD</tt>
), step increments (<tt>P1SP</tt>), and <tt>NPTS</tt>. For the other three
positioners, the same parameters are available minus the <tt>NPTS</tt> field,
since that applies to all. The parameters that pertain to the same positioner
are a set. The record imposes an upper limit (<tt>MPTS</tt>) on <tt>NPTS</tt>.
Both <tt>MPTS</tt> and <tt>NPTS</tt> are configured by the user. The positioner
width, configurable in the <tt>P1WD</tt> -<tt>P4WD</tt>  fields, may be
negative.

<p>For <i>n</i> in [1..4]:<br>

<table BORDER>

<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>P<i>n</i>SP</tt></td>
<td>Positioner <i>n</i> Starting Point</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>EP</tt></td>
<td>Positioner <i>n</i> Ending Point</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>CP</tt> </td>
<td>Positioner <i>n</i> Center Point</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>WD</tt> </td>
<td>Positioner <i>n</i> Width</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>SI</tt> </td>
<td>Positioner <i>n</i> Step Increment</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

</table>

<p>Some of these fields can be redundant. For instance, the positioner width
(<tt>P1WD</tt> -<tt>P4WD</tt> ) is simply the distance from the starting
position to the ending position (<tt>P<i>n</i>EP</tt>  - <tt>P<i>n</i>SP</tt>
). The record calculates redundant parameters for the same set, if the
parameters are left undefined. However, the user can still configure the
redundant parameters anyway.

<p>There is no unique prescription for removing inconsistencies among redundant
parameters, and no hard-coded set of preferences among parameters is likely to
please everyone. Therefore, the SSCAN record allows the user to "freeze"
parameters with flags so that they will not be changed by the record's internal
attempts to ensure consistency among the parameter set. Frozen parameters can
be changed by the user and by any other client, but not by the record. It is
the user's responsibility to ensure that frozen parameters do not prevent
freely specifying unfrozen parameters. For example, if both
<tt>P<i>n</i>SI</tt>  and <tt>NPTS</tt> are frozen, changes to
<tt>P<i>n</i>WD</tt>  will be rejected. Similarly, if both
<tt>P<i>n</i>SP</tt>  and P<i>n</i>CP are frozen, changes to
<tt>P<i>n</i>EP</tt>  and <tt>P<i>n</i>WD</tt> will have no effect. By default,
<tt>P<i>n</i>SP</tt> , <tt>P<i>n</i>SI</tt> , and <tt>NPTS</tt> are frozen.
When the record cannot adjust the parameters to be consistent, a flag is raised
in the alert field (<tt>ALRT</tt>) and a message reported in the state message
field (<tt>SMSG</tt>).

<p>The freeze flag override field (<tt>FFO</tt> ) has two choices: <tt>Use
F-Flags</tt> and <tt>Override</tt>. <tt>Override</tt> causes the current
settings of all the freeze flags to be saved and monitors to be called for
those that have changed. <tt>Use F-Flags</tt> causes the flags saved with the
<tt>Override</tt> command to be restored if any have changed. Changing the
choice of this field at run-time causes the special record support routines to
perform these actions. So if <tt>Override</tt> is chosen at run-time, then all
current settings are saved, and can be restored at a later time by changing the
<tt>FFO</tt>  field to <tt>Use F-Flags</tt>.

<p>For <i>n</i> in [1..4]:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>FPTS</tt> </td>
<td>Freeze Flag for <tt>NPTS</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"FREEZE" (1)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>FFO</tt> </td>
<td>Freeze Flag Override</td>
<td>Menu ("USE F-FLAGS", "OVERRIDE")</td>
<td>Yes</td>
<td>"USE F-FLAGS" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FS</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>SP</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FE</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>EP</tt> </td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FI</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>SI</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FC</tt></td>
<td>Positioner <i>n</i> Freeze Flag for <tt>P<i>n</i>CP</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>FW</tt></td>
<td>Positioner n Freeze Flag for <tt>P<i>n</i>WD</tt></td>
<td>Menu ("NO", "FREEZE")</td>
<td>Yes</td>
<td>"NO" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</table>

<p>Although this approach may seem to present the user with an overwhelming
number of choices when it comes to linear scans, it should be noted that by
default the user only has to configure <tt>NPTS</tt>, and the starting position
(<tt>P<i>n</i>SP</tt>) and the step increment (<tt>P<i>n</i>SI</tt>) fields for
each positioner in order to fully define the scan of a positioner. The operator
interface (usually DM, medm or another CA client) need only present the user
with these fields. However, by changing the freeze flags from the defaults and
presenting the user with different fields to fill in, the scan can be defined
in a completely flexible way. The result is that a simple scan can be defined
easily, but advanced users are not limited in flexibility.

<p><a NAME="HEADING_2-3"></a>
<h2>2.3. Table Mode</h2>

In <tt>Table</tt> mode, the user provides the values for the
<tt>P<i>n</i>PA</tt> arrays prior to the start of a scan. These arrays are used
only in <tt>Table</tt> mode.

<p>For <i>n</i> in [1..4]:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>P<i>n</i>PA</tt> </td>
<td>Positioner <i>n</i> Position Array</td>
<td>DOUBLE array</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
</table>

<p><a NAME="HEADING_2-4"></a>

<h2>2.4. Position Verification, Readback Process Variable, and Delta
Parameters</h2>

For each positioner, the user may specify a process variable in the
<tt>R1PV</tt> -<tt>R4PV</tt>  fields that corresponds to the actual (or
measured) position of the motor. If this readback field is configured, the
SSCAN record will confirm after each movement that the actual position is
within a specified delta to the desired position. The delta is specified in the
<tt>R1DL</tt> -<tt>R4DL</tt>  fields. If the delta is exceeded, the scan will
abort and the record will go into an alarm state. A text field within the
record (<tt>SMSG</tt>) will inform the operator of the error condition.

<p>For <i>n</i> in [1..4]:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>R<i>n</i>PV</tt> </td>
<td>Readback <i>n</i> Process Variable&nbsp;</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>NV</tt></td>
<td>Readback <i>/n</i> Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>DL</tt> </td>
<td>Readback <i>n</i> Delta&nbsp;</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>

<p><a NAME="HEADING_2-5"></a>

<h2>2.5. Detector Triggers and Command Data</h2>

If valid process variable names are entered into the detector trigger fields
(<tt>T1PV</tt>-<tt>T4PV</tt> ) fields, the SSCAN record will write the
specified command data (the floating point numbers <tt>T1CD</tt>-<tt>T4CD</tt>
) to those process variables between the positioning phase and the data
acquisition phase.  If no detector trigger field contains a valid PV, the SSCAN
record will skip this step and acquire the data immediately.<p>

For <i>n</i> in [1..4]:<br>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>T<i>n</i>PV</tt></td>
<td>Detector Trigger <i>n</i> Process Variable&nbsp;</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>T<i>n</i>NV</tt></td>
<td>Trigger <i>n</i> Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>T<i>n</i>CD</tt></td>
<td>Trigger <i>n</i> Command Data</td>
<td>FLOAT</td>
<td>Yes</td>
<td>1</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>

<p><a NAME="HEADING_2-6"></a>

<h2>2.6. Delay variables</h2>

Generally, after the SSCAN record has written to positioners and waited for all
positioners to declare themselves done, it waits an additional settling time,
specified in seconds by the <tt>PDLY</tt> field, before entering the next scan
phase. Similarly, after detector triggers have declared themselves done, the
SSCAN record waits for <tt>DDLY</tt> seconds before reading positioner and
detector data.

<P>If no positioners are defined, then <tt>PDLY</tt> is ignored.  If no
detector triggers are defined, then <tt>DDLY</tt> is ignored.  <tt>PDLY</tt>
does not apply to after-scan positioner motions.

<p><a NAME="HEADING_2-7"></a>

<h2>2.7. Client handshaking variables</h2>

Immediately before data are to be read from positioners and detectors, the
SSCAN record checks the <tt>WCNT</tt> field.  If this field is nonzero, the
SSCAN record waits until it gets set to zero before reading data and continuing
with the scan.  The <tt>WCNT</tt> is not directly writable by clients. 
Instead, a client wanting to put a hold on the scan writes a "1" to the
<tt>WAIT</tt> field, which increments <tt>WCNT</tt> by one.  When the client is
ready for the scan to continue, it writes a "0" to the <tt>WAIT</tt> field,
which decrements the <tt>WCNT</tt> field.  This mechanism allows several
clients independently to handshake with the SSCAN record, and it is intended or
two purposes:

<P>1) A data-storage client can put a hold on a SSCAN record whose data it is
writing by writing to the <tt>AWAIT</tt> field.  This hold doesn't prevent the
record from executing, or even from acquiring new data, but it does prevent the
record from switching data buffers.

<P>2) In a multidimensional scan, a data-storage client can put a hold on scan2
while it is writing data from scan1, by writing to the <tt>WAIT</tt> field. 
This relatively inefficient handshake is still used by some data-storage
clients.

<P>3) A data-acquisition client that doesn't declare completion via EPICS'
putNotify mechanism can declare completion using <tt>WAIT</tt>.

<P>A client may not be able to write quickly enough to <tt>WAIT</tt> to ensure
that the scan holds before data acquisition.  In this case, the client can
cause the SSCAN record to write automatically to <tt>WCNT</tt> whenever
detectors are triggered, by incrementing the value of the <tt>AWCT</tt> field. 
The client must remember to decrement <tt>AWCT</tt> before exiting, otherwise
scans will hang waiting for a nonexistent client.

<P>A client may not be able to write quickly enough to <tt>AWAIT</tt> to ensure
that the scan holds before switching buffers.  In this case, the SSCAN record
can be made to write automatically to <tt>AWAIT</tt> whenever data are posted,
by setting the <tt>AAWAIT</tt> field to "1". 

<P><table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>WAIT</tt></td>
<td>Wait for client</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>WCNT</tt></td>
<td>Wait count</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>AWCT</tt></td>
<td>Auto Wait</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>WTNG</tt></td>
<td>Waiting</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr colspan=9><td colspan=9></td></tr>

<tr>
<td><tt>AWAIT</tt></td>
<td>Waiting for data-storage client</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>

<tr>
<td><tt>AAWAIT</tt></td>
<td>AutoWait for data-storage client</td>
<td>MENU ("NO","YES")</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

</table>

<p><a NAME="HEADING_3"></a>

<h1>3. Data Acquisition Parameters</h1>

<hr>Each SSCAN record can acquire data from up to 74 process variables (70
detector signals, <tt>D01</tt>-<tt>D70</tt>, and four positioner readbacks,
<tt>R1</tt>-<tt>R4</tt>) at each point in the scan. These data will most
commonly be from a detector or from a position readback (which would record the
actual motor positions at each point and could then be compared to the desired
position array).  Although positioner readbacks are normally used to confirm
the position at which data actually were acquired (as opposed to the position
to which the SSCAN record <i>told</i> a positioner to go), they can be used to
record any data.  These four variables are the only place to record
double-precision scan data.

<p>The scan results will most frequently be read as position arrays
(<tt>P1RA</tt>-<tt>P4RA</tt>) and arrays of detector data
(<tt>D01DA</tt>-<tt><tt>D70DA</tt></tt>) where each detector data element
corresponds to the position element.

<p>A one-dimensional scan is complete when the <tt>BUSY</tt> field
goes back to zero (during the scan its value is 1). A client program monitoring
the scan can read the position and data arrays when the <tt>DATA</tt> field is
set to 1. (The client could have a monitor set on the data-array fields so the
record will post them when the scan is finished.)

<p>For two-dimensional scans, the client should read the arrays from the scan1
record after the completion of each inner scan and associate these data with
the current outer-scan information.  (Let's call the inner scan 'x', and the
outer scan 'y'.)  This will allow the client to display data after each x scan.
The SSCAN record will buffer the data for only one x scan, so the client must
read the arrays before the next x scan is completed.  If the scan is too fast
for this, see <a href="#HEADING_1-3">section 1.3. - Handshaking with
clients</a>

<p>During slow scans, the application program may want to display scan progress
point-by-point. The SSCAN record posts monitors on fields that it updates each
point, but it doesn't post point-by-point monitors faster than 20 times per
second. If a scan is proceeding at a rate less than 20 points per second, every
point will be posted. If a scan is proceeding at 100 steps per second, scalar
values will be posted approximately every 5th point. In either case, the array
data will contain every point at the completion of the scan.

<p>Special Acquisition Parameters:<br>

<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr><td colspan=9>version 5.16 and earlier:</td></tr>

<tr>
<td><tt>ACQM</tt></td>
<td>Acquisition Mode</td>
<td>Menu ("NORMAL", "ACCUMULATE", "ADD TO PREV", "GET ARRAYS")</td>
<td>Yes</td>
<td>"NORMAL" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr><td colspan=9>version 5.17 and later:</td></tr>

<tr>
<td><tt>ACQM</tt></td>
<td>Acquisition Mode</td>
<td>Menu ("NORMAL", "ACCUMULATE", "ADD TO PREV")</td>
<td>Yes</td>
<td>"NORMAL" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><tt>ACQT</tt></td>
<td>Acquisition Type</td>
<td>Menu ("SCALAR", "1D ARRAY")</td>
<td>Yes</td>
<td>"SCALAR" (0)</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</table>

<p>Data and Execution Flags:<br>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td colspan=9>For <i>nn</i> in [01..70] (e.g., "D01PV", "D02PV", ... "D70PV") :</td>
</tr>

<tr>
<td><tt>D<i>nn</i>PV</tt></td>
<td>data <i>nn</i> Process Variable name</td>
<td>STRING [40]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>NV</tt></td>
<td>data <i>nn</i> Name Valid</td>
<td>LONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>DA</tt></td>
<td>Detector <i>nn</i> data Array</td>
<td>FLOAT[ ]</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>EXSC</tt></td>
<td>Execute Scan Flag</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>XSC</tt></td>
<td>Internal copy of <tt>EXSC</tt></td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>BUSY</tt></td>
<td>Scan-is-busy Flag</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>DATA</tt></td>
<td>Data-are-ready flag</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

</table>

<p><a NAME="HEADING_4"></a>

<h1>4. Operator Display Parameters</h1><hr>

Prior to beginning an actual scan, the record can be commanded to check the
scan parameters to ensure that all positioner requests are within reasonable
limits. This is done by writing "1" to the <tt>CMND</tt> field. The record will
do a "dry run" by calculating every positioner value (or looking it up in the
table) and comparing it with the high range and low range values
(<tt>P1HR</tt>-<tt>P4HR</tt> and <tt><tt>P1LR</tt></tt>-<tt>P4LR</tt>)
associated with that positioner's Process Variable. (Drive limits are an
attribute of most process variables).  If any step would exceed the drive
limits, the operator is notified via the <tt>SMSG</tt> field.

<p>Other than that, the High Range and Low Range value fields are only
used as the display limits for an operator interface. The same is true for the
rest of these fields, which are configured to affect the information displayed
to the operator. Each positioner and the detector for each positioner have the
following fields:

<ul> <li> An Engineering Units Field (<tt>P1EU</tt>-<tt><tt>P4EU</tt></tt>,
<tt>D01EU</tt>-<tt>D70EU</tt>), which has a string that is given to it by the
user.</li>

<li> A Precision Field (<tt>P1PR</tt>-<tt>P4PR</tt>,
<tt>D01PR</tt>-<tt>D70PR</tt>), which holds an integer that controls the
decimal precision that the corresponding field is displayed with. For instance,
<tt>P1PR</tt> controls the decimal precision for positioner 1 array
elements.</li>

</ul>

See the EPICS Record Reference Manual for more on the record name
(<tt>NAME</tt>) and description (<tt>DESC</tt>) fields.

<p>
<table BORDER>
<tr>
<th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td colspan=9> For <i>n</i> in [1..4]:</td>
</tr>

<tr>
<td><tt>P<i>n</i>EU</tt></td>
<td>Positioner <i>n</i> Eng. Units</td>
<td>STRING [16]</td>
<td>Yes</td>
<td>16</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>HR</tt></td>
<td>Pos. <i>n</i> High Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt><tt>P<i>n</i>LR</tt></tt></td>
<td>Pos. <i>n</i> Low Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>PR</tt></td>
<td>Pos. <i>n</i> Precision</td>
<td>SHORT</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td colspan=9> For <i>nn</i> in [01..70]:</td>
</tr>

<tr>
<td><tt>D<i>nn</i>EU</tt></td>
<td>Detector <i>nn</i> Eng. Units</td>
<td>STRING [16]</td>
<td>Yes</td>
<td>16</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>HR</tt></td>
<td>Det. <i>nn</i> High Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>LR</tt></td>
<td>Det. <i>nn</i> Low Range</td>
<td>DOUBLE</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>PR</tt></td>
<td>Det. <i>nn</i> Precision</td>
<td>SHORT</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>NAME</tt></td>
<td>Record Name</td>
<td>STRING [29]</td>
<td>Yes</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>DESC</tt></td>
<td>Description</td>
<td>STRING [29]</td>
<td>Yes</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</table>

<p><a NAME="HEADING_5"></a>

<h1>5. Run-time Parameters</h1><hr>

These fields are used to process the record, to implement monitors for certain
fields, and/or to keep track of data for processing and/or for the operator.
None of these fields are configurable by a database configuration tool. Most of
them can be accessed at run-time, and many can be modified at run-time.

<p>The Code Version (<tt>VERS</tt>) field reflects the version of SSCAN record
processing routines.

<p>The <tt>VAL</tt> field is used only as a progress indicator.  It is posted
after all point-by-point PV have been posted.  (So, if a PV you're interested
in hasn't been posted by the time you get the <tt>VAL</tt>-field monitor, that
PV's value hasn't changed since the last time it was posted.)

<p>The State Message (<tt>SMSG</tt>) field holds a message sent by the record
that alerts the operator to an error condition. It can be cleared by writing a
0 to the Command (<tt>CMND</tt>) field.

<p>The Alert (<tt>ALRT</tt>) field is a flag which indicates if an error
condition currently exists. 1 means YES; 0, NO. The cause of the condition will
be displayed in the <tt>SMSG</tt> field.

<p>The scan-phase (<tt>FAZE</tt>) field indicates in which phase of a scan the
record currently is.  The possible phases are as follows:

<table border>

<tr><th>phase</th><th>message</th><th>meaning</th></tr>

<tr><td>0</td><td>IDLE</td><td>Nothing is going on.</td></tr>

<tr><td>1</td><td>INIT_SCAN</td><td>A scan is starting</td></tr>

<tr><td>2</td><td>DO:BEFORE_SCAN</td><td>The next thing to do is trigger the
before-scan link.</td></tr>

<tr><td>3</td><td>WAIT:BEFORE_SCAN</td><td>The before-scan link has been
triggered.  We're waiting for its callback to come in.</td></tr>

<tr><td>4</td><td>MOVE_MOTORS</td><td>The next thing to do is to write to
positioners.</td></tr>

<tr><td>5</td><td>WAIT:MOTORS</td><td>We've told motors to move.  Now we're
waiting for their callbacks to come in.</td></tr>

<tr><td>6</td><td>TRIG_DETECTORS</td><td>The next thing to do is to trigger
detectors.</td></tr>

<tr><td>7</td><td>WAIT:DETECTORS</td><td>We've triggered detectors.  Now we're
waiting for their callbacks to come in.</td></tr>

<tr><td>8</td><td>START_FLY</td><td>This is an on-the-fly scan</td></tr>

<tr><td>9</td><td>RETRACE_MOVE</td><td>The next thing to do it send positioners
to their post-scan positions.</td></tr>

<tr><td>10</td><td>WAIT:RETRACE</td><td>We've told positioners to go to their
post-scan positions.  Now we're waiting for their callbacks to come
in.</td></tr>

<tr><td>11</td><td>DO:AFTER_SCAN</td><td>The next thing to do is trigger the
after-scan link.</td></tr>

<tr><td>12</td><td>WAIT:AFTER_SCAN</td><td>The after-scan link has been
triggered.  We're waiting for its callback to come in.</td></tr>

<tr><td>13</td><td>SCAN_DONE</td><td>The scan is finished.</td></tr>

<tr><td>14</td><td>WAIT:SAVE_DATA</td><td>The scan is waiting for
AWAIT&nbsp;->&nbsp;0 so it can switch data buffers.</td></tr>

<tr><td>15</td><td>SCAN_PENDING</td><td>A scan has been commanded, but has not
yet started</td></tr>

<tr colspan=3><td colspan=3>The remaining menu choices can't be displayed as
strings by CA clients, but should be displayed as numbers.</td></tr>

<tr><td>16</td><td>TRIG_ARRAY_READ</td><td>The scan is about to trigger array
reads (A1PV)</td></tr>

<tr><td>17</td><td>WAIT:ARRAY_READ</td><td>The scan is waiting for a callback
from the array-read PV</td></tr>

<tr><td>18</td><td>PREVIEW</td><td>We're doing a preview of the scan.</td></tr>

</table>


<p>The data-state (<tt>DSTATE</tt>) field indicates in what state is the
processing of data arrays.  The possible states are as follows:

<table border>

<tr><th>state</th><th>message</th><th>meaning</th></tr>

<tr><td>0</td><td>UNPACKED</td><td>Data arrays are either idle or being
filled.  <br>If a client should read an array now, it would get last scan's
data.</td></tr>

<tr><td>1</td><td>TRIG_ARRAY_READ</td><td>The next thing to do is trigger the
array-read PV, <tt>A1PV</tt>.   <br>If a client should read an array now, it
would get last scan's data.</td></tr>

<tr><td>2</td><td>ARRAY_READ_WAIT</td><td><tt>A1PV</tt> has been triggered, and
the callback is still outstanding.   <br>If a client should read an array now,
it would get last scan's data.</td></tr>

<tr><td>3</td><td>SAVE_DATA_WAIT</td><td>Arrays are filled, but cannot be
posted yet because the data-storage client is not finished writing last scan's
data.   <br>If a client should read an array now, it would get last scan's
data.</td></tr>

<tr><td>4</td><td>PACKED</td><td>Arrays are filled, and buffers have been
switched, but they haven't yet been posted.   <br>If a client should read an
array now, it would get last scan's data.</td></tr>

<tr><td>5</td><td>POSTED</td><td>Data arrays have been posted.  <br>Now the
data-storage client can read this scan's array data.</td></tr>

</table>



<p>The command (<tt>CMND</tt>) field supports six commands, as follows:

<table BORDER>

<tr>

<th><tt>CMND</tt></th> <th>Command</th>

<tr><td>0<td>Clear the State Message field (<tt>SMSG</tt>)</td></tr>

<tr><td>1<td>Execute a "dry run", checking the desired position against the
range limits for each positioner</td></tr>

<tr><td>2<td>Check to see if limits would be violated if the currently
programmed scan were actually performed</td></tr>

<tr><td>3<td>Clear all PV's, freeze flags, modes, switches, etc.</td></tr>

<tr><td>4<td>Clear all positioner-related PV's, freeze flags, modes, and 
switches.</td></tr>

<tr><td>5<td>Clear positioner-name PV's.</td></tr>

</table>

<p>The Current Point (<tt>CPT</tt>) field contains the current point of an
active scan. The Desired Value fields for each positioner
(<tt>P1DV</tt>-<tt>P4DV</tt>) contain the desired value of each positioner for
the current point (<tt>CPT</tt>) in the scan. The Readback Current Value
(<tt>R1CV</tt>-<tt>R4CV</tt>) fields contain the current readback value for
each positioner. The Detector Current Value (<tt>D01CV</tt>-<tt>D70CV</tt>)
contain each detector's current value for the current point in the scan. The
event posting for these fields is throttled to 20 Hz, so for fast scans not
every value will be posted.

<p>The <tt>PCPT</tt>, <tt>PXSC</tt>, <tt>P1LV</tt>-<tt>P4LV</tt>,
<tt>R1LV</tt>-<tt>R4LV</tt>, and <tt>D01LV</tt>-<tt>D70LV</tt> fields all contain the previous or
"last" value for their corresponding fields. For instance, the <tt>R1LV</tt>
field contains the last value for the <tt>R1CV</tt> field. These fields are
used to implement monitors for the corresponding field. For instance, if
<tt>CPT</tt> does not equal <tt>PCPT</tt> when the record is processed, then
monitors are triggered for <tt>CPT</tt>.

<p>The Name Valid fields (<tt><i>xx</i>NV</tt>) are flag fields which indicate
if the corresponding process variable field contains an existing process
variable. For instance, the <tt>P1NV</tt> field indicates whether the
<tt>P1PV</tt> field contains a valid process-variable name; the <tt>R4NV</tt>
field indicates whether <tt>R4PV</tt>  contains a valid PV name, and so on.  If
a positioner's PV name field is blank, all other fields associated with that
positioner are ignored.  If a PV name field is not empty, but consists purely
of "whitespace" characters (blanks or tabs, say) then the SSCAN record will
silently set the PV name field to the empty string.

<p>The database Address fields (<tt><i>xx</i>DB</tt>) are of normally of
interest only to the record itself, and are not even accessible at run-time.
They contain pointers to the dbAddr structures of the corresponding process
variables. For instance, <tt>P1DB</tt> points to the dbAddr structure of
<tt>P1PV</tt>.

<P><table BORDER>
<tr><th>Field</th>
<th>Summary</th>
<th>Type</th>
<th>DCT</th>
<th>Initial/Default</th>
<th>Read</th>
<th>Modify</th>
<th>Posted</th>
<th>PP</th>
</tr>

<tr>
<td><tt>VERS</tt></td>
<td>Code Version</td>
<td>FLOAT</td>
<td>No</td>
<td>1.0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>VAL</tt></td>
<td>Value Field&nbsp;</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>SMSG</tt></td>
<td>State Message&nbsp;</td>
<td>STRING [40]</td>
<td>No</td>
<td>Null</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>CMND</tt></td>
<td>Command Field</td>
<td>ENUM</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>ALRT</tt></td>
<td>Alert Field&nbsp;</td>
<td>UCHAR</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>RPVT</tt></td>
<td>Record Private&nbsp;</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>PXSC</tt></td>
<td>Previous Execute Scan</td>
<td>UCHAR</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>CPT</tt></td>
<td>Current Point</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>PCPT</tt></td>
<td>Previous Current Point&nbsp;</td>
<td>SHORT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>TOLP</tt></td>
<td>Time of Last Posting&nbsp;</td>
<td>ULONG</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr><td colspan=9>For <i>n</i> in [1..4]:</td></tr>

<tr>
<td><tt>P<i>n</i>DV</tt></td>
<td>Pos. <i>n</i> Desired Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>LV</tt></td>
<td>Pos. <i>n</i> Last Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>CV</tt></td>
<td>Readback <i>n</i> Current Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>LV</tt></td>
<td>Readback <i>n</i> Last Value</td>
<td>DOUBLE</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>P<i>n</i>DB</tt></td>
<td>Pos. <i>n</i> dbAddr</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>R<i>n</i>DB</tt></td>
<td>Readback <i>n</i> dbAddr</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr><td colspan=9>For <i>nn</i> in [01..70]:</td></tr>

<tr>
<td><tt>D<i>nn</i>CV</tt></td>
<td>Detector <i>nn</i> Current Value</td>
<td>FLOAT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>LV</tt></td>
<td>Detector <i>nn</i> Last Value</td>
<td>FLOAT</td>
<td>No</td>
<td>0</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>

<tr>
<td><tt>D<i>nn</i>DB</tt></td>
<td>Detector <i>nn</i> dbAddr</td>
<td>NOACCESS</td>
<td>No</td>
<td>Null</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>


</table>


</body>
</html>

